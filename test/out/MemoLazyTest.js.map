{"version":3,"file":"MemoLazyTest.js","sourceRoot":"","sources":["../src/MemoLazyTest.ts"],"names":[],"mappings":";;AAAA,+DAA+C;AAC/C,uCAA+B;AAE/B,IAAI,CAAC,wEAAwE,EAAE,KAAK,EAAE,EAAE,MAAM,EAAE,EAAE,EAAE;IAClG,IAAI,aAAa,GAAG,CAAC,CAAA;IACrB,MAAM,IAAI,GAAG,IAAI,eAAI,CAAC,GAAG,EAAE;QACzB,OAAO,OAAO,CAAC,OAAO,CAAC,aAAa,GAAG,EAAE,CAAC,CAAA;IAC5C,CAAC,CAAC,CAAA;IAEF,aAAa,EAAE,CAAA;IACf,MAAM,CAAC,MAAM,IAAI,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAA;IAEjC,aAAa,EAAE,CAAA;IACf,MAAM,CAAC,MAAM,IAAI,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAA;AACnC,CAAC,CAAC,CAAA;AAEF,IAAI,CAAC,2EAA2E,EAAE,KAAK,EAAE,EAAE,MAAM,EAAE,EAAE,EAAE;IACrG,IAAI,aAAa,GAAG,CAAC,CAAA;IACrB,MAAM,IAAI,GAAG,IAAI,+BAAQ,CACvB,GAAG,EAAE,CAAC,aAAa,EACnB,aAAa,CAAC,EAAE;QACd,OAAO,OAAO,CAAC,OAAO,CAAC,aAAa,GAAG,EAAE,CAAC,CAAA;IAC5C,CAAC,CACF,CAAA;IAED,aAAa,EAAE,CAAA;IACf,MAAM,CAAC,MAAM,IAAI,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAA;IAEjC,aAAa,EAAE,CAAA;IACf,MAAM,CAAC,MAAM,IAAI,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAA;AACnC,CAAC,CAAC,CAAA;AAEF,IAAI,CAAC,yFAAyF,EAAE,KAAK,EAAE,EAAE,MAAM,EAAE,EAAE,EAAE;IACnH,IAAI,aAAa,GAAG,EAAE,IAAI,EAAE,EAAE,QAAQ,EAAE,EAAE,IAAI,EAAE,CAAC,EAAE,EAAE,EAAE,CAAA;IACvD,MAAM,IAAI,GAAG,IAAI,+BAAQ,CACvB,GAAG,EAAE,CAAC,aAAa,EACnB,aAAa,CAAC,EAAE;QACd,OAAO,OAAO,CAAC,OAAO,CAAC,aAAa,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAA;IAC1D,CAAC,CACF,CAAA;IAED,MAAM,CAAC,MAAM,IAAI,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAA;IAEhC,aAAa,GAAG,EAAE,IAAI,EAAE,EAAE,QAAQ,EAAE,EAAE,IAAI,EAAE,EAAE,EAAE,EAAE,EAAE,CAAA;IACpD,MAAM,CAAC,MAAM,IAAI,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAA;AACnC,CAAC,CAAC,CAAA","sourcesContent":["import { MemoLazy } from \"builder-util-runtime\"\nimport { Lazy } from \"lazy-val\"\n\ntest(\"[Lazy] reuses the created value even if the selected value has changed\", async ({ expect }) => {\n  let selectedValue = 0\n  const lazy = new Lazy(() => {\n    return Promise.resolve(selectedValue * 10)\n  })\n\n  selectedValue++\n  expect(await lazy.value).toBe(10)\n\n  selectedValue++\n  expect(await lazy.value).toBe(10)\n})\n\ntest(\"[MemoLazy] recomputes the created value if the selected value has changed\", async ({ expect }) => {\n  let selectedValue = 0\n  const lazy = new MemoLazy(\n    () => selectedValue,\n    selectedValue => {\n      return Promise.resolve(selectedValue * 10)\n    }\n  )\n\n  selectedValue++\n  expect(await lazy.value).toBe(10)\n\n  selectedValue++\n  expect(await lazy.value).toBe(20)\n})\n\ntest(\"[MemoLazy] recomputes the created value if the selected deep/internal value has changed\", async ({ expect }) => {\n  let selectedValue = { deep: { property: { here: 0 } } }\n  const lazy = new MemoLazy(\n    () => selectedValue,\n    selectedValue => {\n      return Promise.resolve(selectedValue.deep.property.here)\n    }\n  )\n\n  expect(await lazy.value).toBe(0)\n\n  selectedValue = { deep: { property: { here: 10 } } }\n  expect(await lazy.value).toBe(10)\n})\n"]}